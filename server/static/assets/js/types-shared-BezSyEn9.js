import{r as n,u as f}from"./utils-BjcahYMR.js";import{g as l,s as m}from"./api-shared-BhtujeU1.js";import{S as k}from"./utils-shared-DLZnwTx3.js";class h{week=[];constructor(){this.week=[]}}class b{id=-1;name="";order=0;score=0;imgIds=[];constructor(){this.id=-1,this.name="",this.order=0,this.score=0,this.imgIds=[]}static Copy(t){return{id:t.id,name:t.name,order:t.order,score:t.score,imgIds:t.imgIds?.concat()||[]}}}class S{id=-1;startTs;endTs;allDay=!0;reminder=0;repeat=0;repeatData=new h;repeatEndTs;title;color=0;priority=-1;groupId=-1;order=0;score;subtasks=[];constructor(){this.id=-1,this.startTs=void 0,this.endTs=void 0,this.allDay=!0,this.reminder=0,this.repeat=0,this.repeatData=new h,this.repeatEndTs=void 0,this.title=void 0,this.color=0,this.priority=-1,this.groupId=-1,this.order=0,this.score=void 0,this.subtasks=[],this.startTs=n().startOf("day"),this.endTs=n().startOf("day")}static Copy(t){const s=JSON.parse(JSON.stringify(t));if(s.startTs=s.startTs?n(s.startTs):void 0,s.endTs=s.endTs?n(s.endTs):void 0,s.repeatEndTs=s.repeatEndTs?n(s.repeatEndTs):void 0,s.subtasks=[],t.subtasks)for(const e of t.subtasks)s.subtasks.push(b.Copy(e));return s}}class T{id=-1;name="";userId=-1;schedules=[];save={};constructor(){this.id=-1,this.name="",this.userId=-1,this.schedules=[],this.save={}}static Copy(t){const s=new T;s.id=t.id,s.name=t.name,s.schedules=[];for(const e of t.schedules)s.schedules.push(S.Copy(e));return s.save=JSON.parse(JSON.stringify(t.save)),s}}class u{static CmpScheduleData(t,s,e){const r=(e&&e[t.id]?.state)??0,c=(e&&e[s.id]?.state)??0;if(r!==c)return r-c;const o=t.order??99999,i=s.order??99999;return o!==i?o-i:(t.id??0)-(s.id??0)}static CmpScheduleSubtasks(t,s,e){const r=(e&&e.subtasks&&e.subtasks[t.id])??0,c=(e&&e.subtasks&&e.subtasks[s.id])??0;if(r!==c)return r-c;const o=t.order??99999,i=s.order??99999;return o!==i?o-i:(t.id??0)-(s.id??0)}static setScheduleSave(t,s,e,r){t in s.save||(s.save[t]={});const c=s.save[t];c[e.id]=r;const o=r.score??0;let i=0;if(r.state===1){let d=e.score??0;f(e.subtasks,a=>{d+=a.score??0,r.subtasks[a.id]=1}),d>o&&(i+=d-o,r.score=d)}else r.score&&(i-=e.score??0,r.score=(r.score||0)-(e.score??0));i!==0&&l(s.userId).then(d=>{d.score+=i,m(s.userId,d.score).then(()=>{})})}static updateSchedularData(t,s,e,r,c){const o=k(r);if(c==="all"){if(s.id===-1){const i=t.schedules.reduce((d,a)=>a.id>d?a.id:d,0)+1;s.id=i,t.schedules.push(s)}else{const i=t.schedules.findIndex(d=>d.id===s.id);i!==-1&&(t.schedules[i]=s)}u.setScheduleSave(o,t,s,e)}else if(c==="cur")u.setScheduleSave(o,t,s,e),e.scheduleOverride=s;else return!1;return!0}static parseScheduleData(t){const s=JSON.parse(t);return s.startTs=s.startTs?n(s.startTs):void 0,s.endTs=s.endTs?n(s.endTs):void 0,s.repeatEndTs=s.repeatEndTs?n(s.repeatEndTs):void 0,s}static parseUserData(t){const s=JSON.parse(t);s.schedules===void 0&&(s.schedules=[]),s.save===void 0&&(s.save={});for(let e=0;e<s.schedules.length;e++){const r=s.schedules[e];r.startTs=r.startTs?n(r.startTs):void 0,r.endTs=r.endTs?n(r.endTs):void 0,r.repeatEndTs=r.repeatEndTs?n(r.repeatEndTs):void 0,r.subtasks===void 0&&(r.subtasks=[])}return s}static CountScheduleReward(t){return(t.subtasks?.reduce((s,e)=>s+(e.score??0),0)||0)+(t.score??0)}}export{u as U,T as a};
