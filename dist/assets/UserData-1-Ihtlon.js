var k=Object.defineProperty;var O=(l,s,t)=>s in l?k(l,s,{enumerable:!0,configurable:!0,writable:!0,value:t}):l[s]=t;var i=(l,s,t)=>(O(l,typeof s!="symbol"?s+"":s,t),t);import{i as f}from"./index-BCutpD3H.js";class b{constructor(){i(this,"id",-1);i(this,"name","");i(this,"imgIds",[])}static Copy(s){var t;return{id:s.id,name:s.name,imgIds:(t=s.imgIds)==null?void 0:t.concat()}}}class y{constructor(){i(this,"id",-1);i(this,"startTs");i(this,"endTs");i(this,"allDay",!0);i(this,"reminder",0);i(this,"repeat",0);i(this,"repeatEndTs");i(this,"title");i(this,"color",0);i(this,"priority",-1);i(this,"groupId",-1);i(this,"subtasks",[]);this.startTs=f().startOf("day"),this.endTs=f().startOf("day")}static Copy(s){var r,a,d;const t=JSON.parse(JSON.stringify(s));if(t.startTs=(r=s.startTs)==null?void 0:r.clone(),t.endTs=(a=s.endTs)==null?void 0:a.clone(),t.repeatEndTs=(d=s.repeatEndTs)==null?void 0:d.clone(),t.subtasks=[],s.subtasks)for(const n of s.subtasks)t.subtasks.push(b.Copy(n));return t}}class T{constructor(){i(this,"state",-1);i(this,"subtasks",{});i(this,"scheduleOverride")}static Copy(s){const t=new T;return t.state=s.state,s.subtasks&&(t.subtasks=JSON.parse(JSON.stringify(s.subtasks))),t}}class v{constructor(){i(this,"id",-1);i(this,"name","");i(this,"schedules",[]);i(this,"save",{})}static Copy(s){const t=new v;t.id=s.id,t.name=s.name,t.schedules=[];for(const r of s.schedules)t.schedules.push(y.Copy(r));return t.save=JSON.parse(JSON.stringify(s.save)),t}}class m{constructor(s){i(this,"dt",f().startOf("day"));i(this,"events",[]);i(this,"save",{});s&&(this.dt=s)}}class p{static createMonthData(s,t,r){var u;const a=s.startOf("month");let d=a.startOf("week");const n=[];do{const e=[];for(let c=0;c<7;c++){const o=p.createDayData(d,t);r&&((u=r.value)==null?void 0:u.dt.unix())==d.unix()&&(r.value=o),e.push(o),d=d.add(1,"days")}n.push(e)}while(d.month()==s.month());return{vid:s.year(),month:s.month(),year:s.year(),firstDayOfMonth:a,weekArr:n}}static createWeekData(s,t,r){var e;const a=s.startOf("month");let d=s.startOf("week");const n=[],u=[];for(let c=0;c<7;c++){const o=p.createDayData(d,t);r&&((e=r.value)==null?void 0:e.dt.unix())==d.unix()&&(r.value=o),u.push(o),d=d.add(1,"days")}return n.push(u),{vid:s.year(),month:s.month(),year:s.year(),firstDayOfMonth:a,weekArr:n}}static createDayData(s,t){const r=new m(s),a=s.unix(),d=h(s);let n=t.save[d];n&&Object.keys(n).length===0&&(console.log("delete",d),delete t.save[d],n=void 0);for(const u of t.schedules){const e=y.Copy(u);if(e.startTs&&e.startTs.startOf("day").unix()<=a){if(e.startTs.startOf("day").unix()===a){r.events.push(e);continue}if(e.repeatEndTs&&e.repeatEndTs.unix()<a)continue;e.repeat==1?r.events.push(e):e.repeat==2?s.day()==e.startTs.day()&&r.events.push(e):e.repeat==3?s.date()==e.startTs.date()&&r.events.push(e):e.repeat==4&&s.date()==e.startTs.date()&&s.month()==e.startTs.month()&&r.events.push(e)}const c=n==null?void 0:n[e.id];if(c&&c.scheduleOverride){const o=c.scheduleOverride;o.title&&(e.title=o.title),o.color&&(e.color=o.color),o.priority&&(e.priority=o.priority),o.groupId&&(e.groupId=o.groupId),o.subtasks&&(e.subtasks=o.subtasks)}}return r.save=n,r.events.sort((u,e)=>p.CmpScheduleData(u,e,n)),r}static CmpScheduleData(s,t,r){var n,u,e,c;const a=r&&((n=r[s.id])==null?void 0:n.state)||0,d=r&&((u=r[t.id])==null?void 0:u.state)||0;return a===d?((e=s.id)!=null?e:0)-((c=t.id)!=null?c:0):a-d}static updateSchedularData(s,t,r,a,d){const n=h(a);if(d==="all"){if(t.id===-1){const e=s.schedules.reduce((c,o)=>o.id>c?o.id:c,0)+1;t.id=e,s.schedules.push(t)}else{const e=s.schedules.findIndex(c=>c.id===t.id);e!==-1&&(s.schedules[e]=t)}n in s.save||(s.save[n]={});const u=s.save[n];u[t.id]=r}else if(d==="cur"){n in s.save||(s.save[n]={});const u=s.save[n],e=u[t.id]=r;e.scheduleOverride=t}else return!1;return!0}static parseScheduleData(s){const t=JSON.parse(s);return t.startTs=f(t.startTs),t.endTs=f(t.endTs),t.repeatEndTs=t.repeatEndTs&&f(t.repeatEndTs),t}static parseUserData(s){const t=JSON.parse(s);t.schedules===void 0&&(t.schedules=[]);for(let r=0;r<t.schedules.length;r++){const a=t.schedules[r];a.startTs=f(a.startTs),a.endTs=f(a.endTs),a.repeatEndTs=a.repeatEndTs&&f(a.repeatEndTs),a.subtasks===void 0&&(a.subtasks=[])}return t}}const h=l=>l===void 0?"":l.format("YYYY-MM-DD");export{m as D,T as S,v as U,p as a,h as b,b as c,y as d};
